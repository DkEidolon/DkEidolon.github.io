<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>学习之路——进程与线程（三） | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="进程间通信　　进程间通信有：管道；信号；消息队列；信号量，共享内存，socket通信；">
<meta name="keywords" content="进程与线程">
<meta property="og:type" content="article">
<meta property="og:title" content="学习之路——进程与线程（三）">
<meta property="og:url" content="http://yoursite.com/2018/09/28/学习之路——进程间通信/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="进程间通信　　进程间通信有：管道；信号；消息队列；信号量，共享内存，socket通信；">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-01-05T07:12:03.033Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="学习之路——进程与线程（三）">
<meta name="twitter:description" content="进程间通信　　进程间通信有：管道；信号；消息队列；信号量，共享内存，socket通信；">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-学习之路——进程间通信" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/28/学习之路——进程间通信/" class="article-date">
  <time datetime="2018-09-28T12:25:38.000Z" itemprop="datePublished">2018-09-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习之路/">学习之路</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      学习之路——进程与线程（三）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h1><p></p><p style="background-color:rgb(125,255,0)">　　进程间通信有：管道；信号；消息队列；信号量，共享内存，socket通信；<br><a id="more"></a></p>
<h1 id="1-1管道"><a href="#1-1管道" class="headerlink" title="1.1管道"></a>1.1管道</h1><p>　　实质上就是文件通信，最大的弊端就是效率低，有点事不需要额外的API函数直接使用read，write函数即可。</p>
<h3 id="1-1-1无名管道：pipe"><a href="#1-1-1无名管道：pipe" class="headerlink" title="1.1.1无名管道：pipe"></a>1.1.1无名管道：pipe</h3><pre><code>头文件： #include &lt;unistd.h&gt;
原型： int pipe(int pipefd[2]);
功能：创建并打开一个无名管道
参数： pipefd 一个数组名 这个数组中有两个int型变量
      第0个 存储读的 文件描述符 第1个存储写的文件描述符！
返回值： 成功返回0 失败返回-1 
</code></pre><p>其在文件系统中没有名字，在创建时必须打开并返回文件描述符。<br>　　pipe在创建时返回两个文件描述符，一读一写。<br>并且具备一下功能：</p>
<blockquote>
<p>1、管道有两端 一端读 一端写<br>2、按顺序读取 即可以理解为队列结构！<br>3、内容读取后就没有了 即相当于出队操作<br>4、不支持lseek 偏移文件流<br>5、pipe随着内核持续！ </p>
</blockquote>
<p>pipe是全双工的，但要实现同时读写，需要两根管道，一读一写。<br>示例如下：<br>    &gt;   close(pipefd1[0]);//关闭一读<br>        close(pipefd2[1]);//关闭二写<br>        char buf[64] = {0};<br>        write(pipefd1[1],”baba henhao!”,13);//向一写写入数据<br>        read(pipefd2[0],buf,64);读取二读读到的数据<br>        printf(“read success is %s”,buf);</p>
<p><strong>只有有亲缘关系的进程才能使用无名管道通信。</strong></p>
<h3 id="1-1-2有管道：fifo"><a href="#1-1-2有管道：fifo" class="headerlink" title="1.1.2有管道：fifo"></a>1.1.2有管道：fifo</h3><pre><code>头文件： #include &lt;sys/types.h&gt;
        #include &lt;sys/stat.h&gt;
原型： int mkfifo(const char *pathname, mode_t mode);
功能：创建一个有名管道
参数：  pathname 文件名 包括路径
           mode 创建时的权限：0777
返回值： 成功返回0 失败返回-1 
</code></pre><p>创建后由open打开，打开规则如下：</p>
<blockquote>
<p>flags = O_RDONLY :open打开即以阻塞方式只读打开<br>flags = O_WRONLY ：open打开即以阻塞方式只写打开<br>flags = O_RDONLY | O_NOBLOCK: open打开 即以非阻塞方式 只读打开<br>flags = O_WRONLY | O_NOBLOCK: open打开 即以非阻塞方式 只写打开</p>
</blockquote>
<p>删除一个有名管道：</p>
<pre><code>&gt;原型：int unlink(const char *path);
 参数： path 带路径的文件名
</code></pre><p>FIFO是在pipe的基础上给管道添加了个名字，真实存在，可以被多个进程打开读写，内核不会将数据写入到文件中，而是保存在内核，所以FIFO文件中没有内容，通常情况下，打开一端会阻塞，直到另一端打开才会成功。</p>
<blockquote>
<p>阻塞方式：<br>　　阻塞的读或者写：<br>　　读时： 如果没有数据 则read阻塞 //即等待数据到来<br>　　写时： 如果没有空间 则write阻塞 //即等待有空间 即另一方读完后再写<br>非阻塞的方式：<br>　　以非阻塞的方式读写<br>　　读时： 如果没有数据 就立即返回 read返回0  并设置响应的错误码！<br>　　写时： 如果没有空间 就立即返回 write返回0 并设置相应错误码！<br>打开：<br>　　只读打开： 总会打开！<br>　　只写打开：只有当只读打开了读端 才能打开写端！</p>
</blockquote>
<h2 id="1-2-信号"><a href="#1-2-信号" class="headerlink" title="1.2 信号"></a>1.2 信号</h2><p>signal：实现IPC的一种方式，<strong>本身不会传输数据！</strong>意思就是，给你一个眼神，你自己体会！</p>
<h3 id="1-2-1信号的实现"><a href="#1-2-1信号的实现" class="headerlink" title="1.2.1信号的实现"></a>1.2.1信号的实现</h3><p>　　就是中断，当一个进程收到某个信号时，内核打断这个进程的执行，转到内核中，查看信号对应的信号处理函数，然后去执行对应的信号处理函数，再返回内核，清除信号，返回断点。</p>
<p>信号的处理方式：</p>
<blockquote>
<p>1、SIG_IGN: ignore 忽略该信号</p>
</blockquote>
<p>注意： 有两个信号不能被忽略 SIGKILL 杀死信号    SIGSTOP 停止信号 </p>
<blockquote>
<p>原因：这是从外部结束进程的唯一方式！也是系统维护的一种方式！</p>
</blockquote>
<p>2、SIG_DFL: default 采用操作系统默认的处理方式<br>默认处理方式 一般有三种：<br>Term: 中止进程<br>Core: 将进程使用的物理资源线 dump 出来 再终止！<br>Ign: 忽略信号 </p>
<blockquote>
<p>3、捕获信号<br>即 用户收到某个信号时，这个信号的处理方式用户程序自己决定<br>也就是把一个信号 与一个信号处理函数关联起来的这个过程称之为信号捕获！</p>
</blockquote>
<p>以上，看似把信号搞得很复杂，其实真的很复杂，只是作为初学者的我搞不懂，也没必要搞懂，看函数就好了。函数如下：</p>
<h3 id="1-2-2信号的API函数"><a href="#1-2-2信号的API函数" class="headerlink" title="1.2.2信号的API函数"></a>1.2.2信号的API函数</h3><p>改变信号的处理方式：</p>
<pre><code>头文件： #include &lt;signal.h&gt;
原型： sighandler_t signal(int signum, sighandler_t handler);
功能：用来将一个指定的信号 与一个信号处理函数关联起来！
参数: signum 信号的值
     handler 指向信号处理函数的指针 即函数名！
返回值： 返回上一次给信号处理的方式！
</code></pre><p>其实相当于跳转，收到某个信号，跳转执行另一个函数，这个函数 必须为void 函数名（int signal）；</p>
<p>等待一个信号<br>    &gt;头文件： #include &lt;unistd.h&gt;<br>    原型： int pause(void);<br>    功能：使调用该函数的进程或者线程 进入等待模式！即阻塞等待一个信号的出现！<br>    参数：无；<br>    返回值： 该函数仅在捕获到信号并返回信号处理函数时返回-1  并且 ERRNO 被设置为 EINTR<br>            表示：已捕获到信号并处理完成！<br>发送一个信号<br>    &gt;头文件： #include &lt;sys/types.h&gt;</p>
<pre><code>         #include &lt;signal.h&gt;
原型： int kill(pid_t pid, int sig);
功能：向指定的进程或者进程组 发送一个指定信号
参数: pid，制定的信号接收者
      &gt;0  表示指定的信号
      =0  表示该进程同组的所有进程
     ==-1 发送给有权发送的所有进程
      &lt;-1 表示看不懂，不解释
     sig：指定的信号，一个整数，比如9就是杀死。
返回值： 成功返回0 ，失败返回-1
</code></pre><h2 id="1-3-system-V-IPC通信"><a href="#1-3-system-V-IPC通信" class="headerlink" title="1.3 system V IPC通信"></a>1.3 system V IPC通信</h2><blockquote>
<p>system V msg: 即消息队列<br>system V sem:即信号量<br>system V shm:共享内存</p>
</blockquote>
<p>双数三种机制称之为system V IPC,源于system V unix， 原理均为在内核中开辟一块空间，进程通过该空间读写数据实现通信，不使用文件系统的API函数。</p>
<blockquote>
<p>函数汇总：<br>　　　　　　　　　　　    消息队列　　　　　　　信号量：　　　　　　共享内存<br>　　头文　　　　　　　sys/msg.h　　　　　　ys/sem.h    　　　　　　sys/shm.h</p>
</blockquote>
<pre><code>创建或打开IPC        msgget()            　semget()        　　shmget()      ***get()

控制IPC操作    　　　msgctl()        　　　semctl()        　　　shmctl()      ***ctl

IPC操作函数　　    msgsnd/msgrcv　　　　　　semop        　    shmat/shmdt
</code></pre><p>实现方式：<br>1、申请钥匙 KEY<br>    KEY代表一个唯一一个system V IPC 的对象。</p>
<pre><code>&gt;头文件： #include &lt;sys/types.h&gt;
         #include &lt;sys/ipc.h&gt;
原型： key_t ftok(const char *pathname, int proj_id);
功能：用来生成一个唯一的System V IPC对象的KEY!
参数: pathname 一个已经存在的路径
     proj_id 一个整数标志
返回值： 成功返回一个 键key_t类型！
        失败返回-1 同时 errno被设置！
</code></pre><p>P1与P2要进行通信，KEY要相同，即路径与整数标志相同。<br>P3与P4通信，KEY与P1P2的KEY不能相同，容易出问题。不深究，别那么用就好了。</p>
<h3 id="1-3-1-消息队列"><a href="#1-3-1-消息队列" class="headerlink" title="1.3.1 消息队列"></a>1.3.1 消息队列</h3><p>第一步，创建钥匙</p>
<blockquote>
<p>int key = ftok(path,id);</p>
</blockquote>
<p>第二步  创建一个消息队列<br>    &gt;原型：int msgget(key_t key, int msgflg);<br>    &gt;参数：key：申请的钥匙<br>          msgflg：标志位<br>            创建：IPC_CREAT|0777<br>            打开：0<br>    返回值：成功返回一个id，标记消息队列<br>           失败返回-1，错误存放error    </p>
<blockquote>
<p>实例：int id = msgget(key,IPC_CREAT|0777);</p>
</blockquote>
<p>第三步  给消息队列的结构体分配空间</p>
<blockquote>
<p>Msg<em> msg1 = (Msg</em>) malloc(sizeof(Msg)+22);</p>
</blockquote>
<p>结构体如下：</p>
<blockquote>
<p>typedef struct msg{<br>　　struct msg *next ;//指向下一个消息<br>　　int type;//类型<br>    　　long msgtype;//长度<br>    　　char msg_txt[0];//内容<br>}Msg;</p>
</blockquote>
<p>其中，<strong>msg_txt[0]为柔性数组，代表可控大小的缓冲区，分配空间时，malloc（结构体+size），size就是柔性数组的实际大小。</strong></p>
<p>第四步 给结构体内容赋值</p>
<p>　　结构体就不过多解释了，就结构体内容赋值就好了，再加入到消息队列当中。</p>
<p>第五步    读写</p>
<p>发送：<br>    &gt;原型：int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);<br>    &gt;功能：发送消息<br>    &gt;参数： msqid  消息id<br>           msqp   要发送的结构体<br>           msqsz  大小<br>           msqflg 标志 0阻塞，IPC_NOWAIT非阻塞<br>    返回值：成功0 ，失败-1</p>
<blockquote>
<p>实例：msgsnd(id,msg1,22,0);</p>
</blockquote>
<p>接收：<br>    &gt;原型：ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);<br>    &gt;功能：接收消息<br>    &gt;参数： msqid  消息id<br>           msqp   要发送的结构体<br>           msqsz  大小<br>           msgtyp 消息的类型 如果类型不匹配将会过滤不接受！<br>           msqflg 标志 0阻塞，等待信息来<br>                      IPC_NOWAIT非阻塞，没有就开溜<br>    返回值：成功返回实际读取到的字节数 ，失败-1</p>
<blockquote>
<p>实例：msgrcv(id,msg1,22,10086,0);</p>
</blockquote>
<p>第六步 关闭<br>    &gt;原型：ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,int msgflg);<br>    &gt;功能：控制消息队列<br>    &gt;参数： msqid  消息id<br>    &gt;　　　cmd 控制的命令 ：<br>    &gt;　　　　　IPC_RMID 删除消息队列<br>    &gt;　　　　　IPC_SET 设置消息队列属性<br>                                　　　　　IPC_STAT 返回消息队列属性 </p>
<pre><code>&gt;　　　buf 根据 cmd确定 
&gt;　　　如果是 IPC_RMID 则填写NULL
&gt;　　　如果是 IPC_SET 则为设置属性的结构体指针 
&gt;　　　如果是 IPC_STAT 则为读取时 将存储属性的结构体指针 
&gt;返回值： 成功返回0 失败返回-1 
</code></pre><blockquote>
<p>实例：msgctl(id,IPC_RMID,NULL);</p>
</blockquote>
<h3 id="1-3-2-共享内存"><a href="#1-3-2-共享内存" class="headerlink" title="1.3.2 共享内存"></a>1.3.2 共享内存</h3><h3 id="1-3-2-1-原理"><a href="#1-3-2-1-原理" class="headerlink" title="1.3.2.1 原理"></a>1.3.2.1 原理</h3><p>　　<strong>在内核或者设备内存中开辟一块空间 进程A 可以将这块内存映射到自己的进程空间 那进程B也可以将这段空间映射到自己的地址空间 那么如果A 修改了 这个空间的内容，就对应的修改了B中的内容！    </strong></p>
<p>###3.2.2API函数<br>第一步创建钥匙（fork函数）</p>
<p>第二步 创建或打开一个共享内存（shmget函数）</p>
<pre><code>头文件：#include &lt;sys/ipc.h&gt;
       #include &lt;sys/shm.h&gt;

原型：int shmget(key_t key, size_t size, int shmflg);
参数： key: 获取的钥匙 
      size 共享内存的大小 必须为 页的整数倍  一页即4k 4096字节 
      shmflg 标志位 
        1、创建
            IPC_CREAT | 权限位 
        2、 0 打开 
返回值： 成功返回共享内存的id 失败返回-1 错误被存放于errno !
</code></pre><blockquote>
<p>实例：<br>shmget(SEM_SHM_key,4096,IPC_CREAT | 0664);</p>
</blockquote>
<p>第三步 映射（shmat函数）</p>
<pre><code>头文件：#include &lt;sys/types.h&gt;
       #include &lt;sys/shm.h&gt;

原型：void *shmat(int shmid, const void *shmaddr, int shmflg);
参数： shmid:共享内存的id 
    shmaddr 指定要映射到那一块地址上 
            如果我不知道怎么办？就写NULL 由操作系统自行分配 
    shmflg 映射标志 
        1、SHM_RDONLY 只读映射
        2、0 读写 
返回值： 成功返回映射区域的首地址 失败返回 NULL 错误存放在 errno
</code></pre><blockquote>
<p>char<em>data_p=(char</em>)shmat(DATA_SHM_id,NULL,0);</p>
</blockquote>
<p>第四步 操作（shmctl函数）</p>
<pre><code>头文件：#include &lt;sys/ipc.h&gt;
       #include &lt;sys/shm.h&gt;

原型：int shmctl(int shmid, int cmd, struct shmid_ds *buf);
参数： shmid 共享内存id 
       cmd 操作指令 
            IPC_RMID 删除 
    buf 
        当 cmd == IPC_RMID 时写NULL
返回值： 
成功返回 0 失败返回-1 错误存放在errno 
</code></pre><p>第五步 解映射（shmdt函数）</p>
<pre><code>int shmdt(const void *shmaddr);
</code></pre><p>但是由于共享内存以及时间片轮转的问题，可能导致数据在写入时产生冲突，所以需要对共享内存的资源进行保护。引入信号量的概念。</p>
<h2 id="3-3-信号量"><a href="#3-3-信号量" class="headerlink" title="3.3 信号量"></a>3.3 信号量</h2><p><strong>信号量是一种用来提供给不同进程或一个进程之间不同线程进行同步机制的一种手段。</strong></p>
<p>信号量只为保护共享资源而存在。传说中的骑士精神。厕所大妈==信号量，厕所==共享内存，a，b为不同的进程。大妈要知道有几个厕所，a去上厕所，大妈说ok去吧，还有位置。b来了，也要上厕所，大妈说，不行，有人了，你等一会儿。a出来了，b才能进去。很粗俗，也容易懂。</p>
<p>###3.3.1 API函数<br>创建信号量</p>
<pre><code>头文件：#include &lt;sys/types.h&gt;
       #include &lt;sys/ipc.h&gt;
       #include &lt;sys/sem.h&gt;

原型：int semget(key_t key, int nsems, int semflg);
参数： key : 获取的钥匙 
     nsems: 信号量集中包括的信号量的个数 
    如果不要创建信号量集只要打开 这个参数的值应该为0 一旦创建该值不可更改！
   semflg: 标志 
        1、创建 IPC_CREAT | 权限位 
        2、打开 0 
返回值： 成功返回信号量集的id(sem_t类型),失败返回-1 错误存储在 errno
</code></pre><p>实例：</p>
<blockquote>
<p>sem_tsem_shm_p=(sem_t)semget(SEM_SHM_id,NULL,0); </p>
</blockquote>
<p>###3.3.2 PV操作<br>    头文件：#include &lt;sys/types.h&gt;</p>
<pre><code>#include &lt;sys/ipc.h&gt;
#include &lt;sys/sem.h&gt;
struct sembuf{
unsigned short sem_num; /指哪一个信号量
short    sem_op;  
    信号量的操作 是一个 有符号的short类型 
     即做了相关操作后 semval = 原semval + sem_op
     sem_op &gt;0 表示 V 操作 一般会置为   +1 ！
     ste_op &lt;0 表示 P操作 一般会置为    -1
     ste_op ==0 自己尝试 看看是否就会阻塞！
short    sem_flg; 
    操作标志：
    0 表示默认 
    IPC_NOWAIT 非阻塞 
        如果是P操作 信号量没有获取到则直接走人 返回-1 表示不能获取！
    SEM_UNDO 撤销 这个标志意义重大！
        为了防止进程带锁退出 如果设置了这个标志 
        内核会额外的记录该进程的PV 操作 当进程退出时 会还原！
}
原型：int semop(int semid, struct sembuf *sops, unsigned nsops);
参数： semid 信号量集id 
    sops: 操作选择的结构体指针
    nsops:对几个信号量进行PV 表示有多少个信号量进行PV 操作 一般写一个1 ！
返回值：成功返回0 失败返回-1 
</code></pre><p>临界区： 对于共享资源的操作指令称之为临界区！</p>
<p>其实pv操作的意思很简单，信号量一般初始值为1，进行一次p操作，初始值变为0，进入临界区，此时其他进程无法对该共享区域进行操作，直到再进行一次v操作，将信号量还原为1，其他进程才能进行操作。</p>
<p>所以一次正常的共享内存的进程间通信需要以下几个步骤<br>第一步：创建钥匙（共享内存和信号量两个钥匙）（ftok函数）<br>第二步：创建一个共享内存（shmget函数）<br>第三步：映射（shamt函数）<br>第四步：创建信号量（semget函数）<br>第五步：p操作（op.sem_op = -1;op.sem_flg = SEM_UNDO）（semop函数）<br>第六步：临界区操作（对共享内存操作）<br>第七步：v操作（op.sem_op = 1;）（semop函数）</p>
<h2 id="3-4-POSIX"><a href="#3-4-POSIX" class="headerlink" title="3.4 POSIX"></a>3.4 POSIX</h2><p><strong>编译要加 -pthread</strong></p>
<h3 id="3-4-1-有名和无名信号量"><a href="#3-4-1-有名和无名信号量" class="headerlink" title="3.4.1 有名和无名信号量"></a>3.4.1 有名和无名信号量</h3><p><strong>有名信号量</strong>：可以用于 进程间 以及同进程的多个线程间通信 互斥资源。在文件系统中有一个入口  信号量却存在内核中 随着内核持续！ 既可以应用于任意进程 也可以用于线程！<br><strong>无名信号量</strong>：没有名字 基于内存信号量 表示信号量在内存中 这个信号量仅存在某个进程的地址空间 ，可用于同进程的线程间通用。如果，无名信号量存在于进程共享的内存空间则可用于 进程间通信！</p>
<h3 id="3-4-1-API函数"><a href="#3-4-1-API函数" class="headerlink" title="3.4.1 API函数"></a>3.4.1 API函数</h3><p>创建有名信号量：</p>
<pre><code>头文件：#include &lt;fcntl.h&gt;           
       #include &lt;sys/stat.h&gt;       
       #include &lt;semaphore.h&gt;

原型：sem_t *sem_open(const char *name, int oflag);
     sem_t *sem_open(const char *name, int oflag,mode_t mode, unsigned int value);
参数： name 表示信号量的名字 必须包括路径 且是绝对路径 
//注意：必须以/开头 并且 只能有一个 / 后面就是文件名 
   oflag 标志位 
    0 默认 即打开 
    O_CREAT 创建  后续可以跟的测试参数同 open 
    mode 创建的权限 同open 
    value 信号量的初始值 
返回值： 成功返回sem_t的一个指针 指向这个信号量 
        失败 返回 SEM_FAILED 同时 errno被设置 
</code></pre><p>创建一个无名信号量 ：</p>
<pre><code>头文件：#include &lt;semaphore.h&gt;
原型 ：int sem_init(sem_t *sem, int pshared, unsigned int value);
参数 ：
sem:创建无名信号量需要定义一个 sem_t的指针 或者变量  表示存储信号量的地址
    指针： 即malloc 
    变量 ： &amp;变量名 就是其参数 ！
pshared: 该无名信号量的共享方式 
    0 进程内部的线程共享 sem指向的地址是进程的内部地址
    1 不同进程间共享 
        如果是这种情况 要保证sem指向的内存 不同进程都要访问到 
        那么sem指向的内存必须是 共享内存！
value:信号量的值
返回值： 成功返回0 失败返回-1  errno被设置 
</code></pre><p>删除有名信号量：int sem_unlink(const char <em>name);<br>删除无名信号量：int sem_unlink(const char </em>name);</p>
<h2 id="3-4-2-PV操作"><a href="#3-4-2-PV操作" class="headerlink" title="3.4.2 PV操作"></a>3.4.2 PV操作</h2><p>p操作：</p>
<pre><code>#include &lt;semaphore.h&gt;

int sem_wait(sem_t *sem);
功能： sem_wait 用来获取参数sem所指定的信号量 阻塞直到获取到信号量 或者出错
    才会返回！
    获取到 返回 0
    错误 返回-1
int sem_trywait(sem_t *sem);
功能：sem_trywait 用来获取sem指定的信号量 即非阻塞方式获取 成功返回0 表示获取到
失败直接立马返回 此时返回-1 
</code></pre><p>v操作：<br>    &gt;int sem_post(sem_t *sem);<br>    功能： 对指定的信号量进行V操作 </p>
<p>文终。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/28/学习之路——进程间通信/" data-id="cjqj4s8xj001ersut7qpl0xo0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/进程与线程/">进程与线程</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/10/11/c-学习概述/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          c++学习概述
        
      </div>
    </a>
  
  
    <a href="/2018/09/20/学习之路 —— 进程与线程/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">学习之路 —— 进程与线程　　（一）</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习之路/">学习之路</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随记/">随记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARM/">ARM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串操作/">字符串操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/电脑随记/">电脑随记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔试常见问题汇总/">笔试常见问题汇总</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/进程与线程/">进程与线程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ARM/" style="font-size: 10px;">ARM</a> <a href="/tags/c/" style="font-size: 10px;">c++</a> <a href="/tags/hexo/" style="font-size: 20px;">hexo</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/字符串操作/" style="font-size: 10px;">字符串操作</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/电脑随记/" style="font-size: 10px;">电脑随记</a> <a href="/tags/笔试常见问题汇总/" style="font-size: 10px;">笔试常见问题汇总</a> <a href="/tags/进程与线程/" style="font-size: 20px;">进程与线程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/04/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2019/01/04/git-hexo搭建前传/">git-hexo搭建前传</a>
          </li>
        
          <li>
            <a href="/2018/12/15/自电脑重装所需步骤/">自电脑重装所需步骤</a>
          </li>
        
          <li>
            <a href="/2018/12/04/UART-IIC-SPI了解及思考/">UART,IIC,SPI了解及思考</a>
          </li>
        
          <li>
            <a href="/2018/12/04/简易的hexo搭建二/">简易hexo的搭建　　（二）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>