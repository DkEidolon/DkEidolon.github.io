<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-hello-world" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/04/hello-world/" class="article-date">
  <time datetime="2019-01-04T15:40:45.480Z" itemprop="datePublished">2019-01-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/04/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/04/hello-world/" data-id="cjqj4s8vi0005rsutt8ui14dq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-git-hexo搭建前传" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/04/git-hexo搭建前传/" class="article-date">
  <time datetime="2019-01-04T06:20:26.000Z" itemprop="datePublished">2019-01-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hexo/">hexo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/04/git-hexo搭建前传/">git-hexo搭建前传</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>此为hexo搭建前传，其为hexo的简易安装做进一步的完善，零基础实现git+hexo个人博客教程。即git账号创建，软件安装，信息配置等信息。</p>
<h3 id="git账号获取"><a href="#git账号获取" class="headerlink" title="git账号获取"></a>git账号获取</h3><p>首先，百度进入github官网，注册账号。输入名称，邮箱，以及密码。</p>
<p><img src="git1.png" alt="git1"></p>
<p>然后校验是否为人机，创建账号。</p>
<p><img src="git1s.png" alt="git1s"></p>
<p>账号设置，选择免费的。</p>
<p><img src="git2.png" alt="git2"></p>
<p>附加选项不选，一般来说个人的话不需要选择。</p>
<p><img src="git3.png" alt="git3"></p>
<p>至此，账号创建成功。</p>
<h3 id="git环境搭建"><a href="#git环境搭建" class="headerlink" title="git环境搭建"></a>git环境搭建</h3><p>下载git for windows——直接百度git for windows，然后下载并安装至熟悉位置。</p>
<p><img src="gitgui.png" alt="gitgui"></p>
<p>完成后，会出现git bush，点击，弹出一个类似于命令行的窗口，说明git安装成功！<br>安装完成后，还需要最后一步设置，在命令行输入：</p>
<blockquote>
<p>$ git config –global user.name “Your Name”</p>
<p>$ git config –global user.email “<a href="mailto:email@example.com" target="_blank" rel="noopener">email@example.com</a>“</p>
</blockquote>
<h3 id="node-js安装"><a href="#node-js安装" class="headerlink" title="node.js安装"></a>node.js安装</h3><p>百度node.js,进入官网下载。安装，一路next，直到结束。<br>重启git bush，输入node -v，得到类似结果。<img src="node1.png" alt="node1">。输入npm -v，也能得到版本号。即安装结束。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/04/git-hexo搭建前传/" data-id="cjqj4s8vg0004rsut0moj2s17" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-自电脑重装所需步骤" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/15/自电脑重装所需步骤/" class="article-date">
  <time datetime="2018-12-15T06:57:53.000Z" itemprop="datePublished">2018-12-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/随记/">随记</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/15/自电脑重装所需步骤/">自电脑重装所需步骤</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="电脑重装"><a href="#电脑重装" class="headerlink" title="电脑重装"></a>电脑重装</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>　　重装系统的第一步就是备份了，记住自己现在电脑有什么是需要保存下来，并且网络上并不好寻找的东西，放置至备份盘中。以下，是自己的备份列表：</p>
<blockquote>
<p>git-hexo文件夹（保存了自己所写的博文）</p>
<p>雨滴桌面资源（可要可不要，资源还是挺好找的）</p>
<p>图标包资源(win10白色图标包)</p>
<p>chrome浏览器插件（友范全网通vip/infinity/tampermonkey）</p>
<p>各式学习软件安装包（Keil uVision5 / Source Insight 4.0 / MATLAB/VMware虚拟机/ubuntu镜像）</p>
<p>各式实用软件安装包（quick look/memreduct/wise hotkey/snipaste/CCleaner/f.lux/7.zip/pandownload/StartIsBackCfg）</p>
</blockquote>
<h3 id="重装"><a href="#重装" class="headerlink" title="重装"></a>重装</h3><p>启动盘——大白菜pe</p>
<p>系统镜像——win10家庭版</p>
<p>进入电脑bios，在boot中将首选启动项选择为u盘，注意，在进bios之前将U盘插入，否则无法检测。</p>
<p>保存设置并启动，进入pe系统，使用磁盘分区助手分盘，选择系统镜像安装。</p>
<h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><p>打开备份软件，逐一安装。</p>
<p>安全软件 —— 火绒；</p>
<p>清理软件 —— ccleaner；</p>
<p>解压软件 —— 7.zip；</p>
<p>护眼软件 —— f.lux；</p>
<p>截屏软件 —— snipaste；</p>
<p>内存清理 —— memreduct；</p>
<p>快捷键选 —— wise hotkey；</p>
<p>百度云盘 —— pandownload；</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>git环境见——git环境搭建。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/15/自电脑重装所需步骤/" data-id="cjqj4s8w1000orsutyv6h4nt7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/电脑随记/">电脑随记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-UART-IIC-SPI了解及思考" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/04/UART-IIC-SPI了解及思考/" class="article-date">
  <time datetime="2018-12-04T08:44:02.000Z" itemprop="datePublished">2018-12-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/UART-IIC-SPI了解及思考/">UART,IIC,SPI了解及思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/04/UART-IIC-SPI了解及思考/" data-id="cjqj4s8va0001rsutfsxsdv1a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-简易的hexo搭建二" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/04/简易的hexo搭建二/" class="article-date">
  <time datetime="2018-12-04T07:31:57.000Z" itemprop="datePublished">2018-12-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/hexo/">hexo</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/04/简易的hexo搭建二/">简易hexo的搭建　　（二）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="启言"><a href="#启言" class="headerlink" title="启言"></a>启言</h2><p>　　从上一次写hexo到现在已经过去了很长一段时间了，利用next美化界面还没写，真的懒啊，但是呢，今天看到关于域名的一些东西（<strong>其实就是腾讯超便宜的域名让我动心了</strong>），突然想起我还用着github的二级域名，没牌面啊。于是，赶紧买个域名，虽然穷，但是穷有穷的装法不是？话不多说，开始吧。</p>
<h2 id="垃圾佬的乐趣——便宜域名的获取及设置"><a href="#垃圾佬的乐趣——便宜域名的获取及设置" class="headerlink" title="垃圾佬的乐趣——便宜域名的获取及设置"></a>垃圾佬的乐趣——便宜域名的获取及设置</h2><p>　　用的是腾讯的域名哈，在空间看到的，就不给他打广告了（三块钱买不了吃亏，买不了上当，但是可以很快乐）。
　　</p>
<p>　　买了之后登陆腾讯云，然后找到域名那块地方。如下图：</p>
<p><img src="简易的hexo搭建二/域名设置1.png" alt="域名设置1"></p>
<p>　　点一下解析，进入第二个界面：</p>
<p><img src="简易的hexo搭建二/域名设置2.png" alt="域名设置2"></p>
<blockquote>
<p>添加记录</p>
<p>主机记录选择: www , @ </p>
<p>记录类型：CNAME,</p>
<p>线路类型:默认，</p>
<p>记录值：就是你的github的库，也就是前文的所写的</p>
</blockquote>
<blockquote>
<p>用户名.github.io</p>
</blockquote>
<p>然后，等等，再等等，再等等，（稍微有点久，至少我有点久），直到进域名的时候，弹出github的404页面。证明成功映射到了github网站啦。在等待的时间可以去执行下一步。</p>
<h2 id="最后的牢骚——hexo本地配置"><a href="#最后的牢骚——hexo本地配置" class="headerlink" title="最后的牢骚——hexo本地配置"></a>最后的牢骚——hexo本地配置</h2><p>打开本地hexo——进入source——创建CNAME文件（不是文件夹，是文件，不带后缀的）——记事本打开——添加域名（不带www，就买的啥样就写啥样）——保存</p>
<p>打开git bash——进入hexo——gexo clean——hexo g——hexo d。</p>
<p>然后，然后刷新域名，就搞定了。</p>
<p>文终。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/04/简易的hexo搭建二/" data-id="cjqj4s8vu000irsutnmk94h9w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/">hexo</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ARM随记" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/20/ARM随记/" class="article-date">
  <time datetime="2018-11-20T10:41:51.000Z" itemprop="datePublished">2018-11-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习之路/">学习之路</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/20/ARM随记/">ARM随记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ARM"><a href="#ARM" class="headerlink" title="ARM"></a>ARM</h1><h3 id="冯诺依曼结构的计算机有哪些组成部分？"><a href="#冯诺依曼结构的计算机有哪些组成部分？" class="headerlink" title="冯诺依曼结构的计算机有哪些组成部分？"></a>冯诺依曼结构的计算机有哪些组成部分？</h3><p>　　控制器，运算器，存储器，输入设备，输出设备</p>
<h3 id="冯诺依曼结构和哈佛结构的区别是什么？"><a href="#冯诺依曼结构和哈佛结构的区别是什么？" class="headerlink" title="冯诺依曼结构和哈佛结构的区别是什么？"></a>冯诺依曼结构和哈佛结构的区别是什么？</h3><p>　　而冯.诺依曼结构将指令存储器和数据存储器合在一起的存储器结构；</p>
<p><img src="ARM随记/冯诺依曼结构.png" alt="冯诺依曼"></p>
<p>　哈佛结构是将指令存储器和数据存储器分开的一种存储器结构；</p>
<p><img src="ARM随记/哈佛结构.png" alt="哈佛">
　　</p>
<h3 id="冯诺依曼结构和哈佛结构相比较，各自的优缺点是什么？"><a href="#冯诺依曼结构和哈佛结构相比较，各自的优缺点是什么？" class="headerlink" title="冯诺依曼结构和哈佛结构相比较，各自的优缺点是什么？"></a>冯诺依曼结构和哈佛结构相比较，各自的优缺点是什么？</h3><p>　　在典型情况下，完成一条指令需要经过三个步骤，取指令，指令译码，执行指令，而冯诺依曼结构的指令存储器和数据存储器在同一存储空间，经由一根总线传输，所以取指令和执行指令不能重叠执行，只能完成一个后再执行下一个。<br><img src="ARM随记/冯诺依曼执行.png" alt="冯诺依曼"></p>
<p>　　而哈佛结构由于取指和执行经由不同的储存空间和总线，使得各条指令能够重叠执行，提高了执行效率。<br><img src="ARM随记/哈佛执行.png" alt="哈佛"></p>
<h3 id="数据总线，地址总线和控制总线"><a href="#数据总线，地址总线和控制总线" class="headerlink" title="数据总线，地址总线和控制总线"></a>数据总线，地址总线和控制总线</h3><p><strong>数据总线（Data Bus）</strong>：</p>
<p>（1）数据总线是cpu和内存或其他期间之间数据交互的通道（双向）</p>
<p>（2）数据总线的宽度决定了cpu和外界的传输速度</p>
<p>（3）每条传输线一次只能传输一位二进制数，也就是说一次可传输数据大小为：2^n</p>
<p><strong>地址总线（Address Bus）</strong>：</p>
<p>（1）cpu通过地址总线来指定存储单元进行获取或存入（单向，从cpu传向外部设备或I/O端口）</p>
<p>（2）地址总线决定了cpu所能访问的最大内存空间的大小2^N,N为地址线数量.</p>
<p><strong>控制总线（Control Bus）</strong>：</p>
<p>（1）用来传送控制信号和时序信号（cpu向存储器或其他设备发送的读写信号，中断响应信号等，也有其他设备反馈给cpu的信号）</p>
<p>（）控制总线的宽度决定了cpu对外部设备的控制能力</p>
<h3 id="CPU的工作原理"><a href="#CPU的工作原理" class="headerlink" title="CPU的工作原理"></a>CPU的工作原理</h3><p>cpu从逻辑上分为三个部分，<code>控制单元</code>，<code>存储单元</code>和<code>运算单元</code>，这三部分由cpu内部总线连接起来。CPU从内存中一条一条地取出指令和相应的数据，按指令操作码的规定，对数据进行运算处理，直到程序执行完毕为止。</p>
<p><img src="ARM随记/cpu.png" alt="cpu"></p>
<p><code>**控制单元**</code>:由指令寄存器IR(instruction register)、指令译码器ID(Instruction Decoder)和操作控制器OC(Operation Controller)等组成。根据用户的程序，从存储器中取出指令，放在指令寄存器IR中，然后通过ID译码器分析应该进行什么操作，最后通过控制操作器按时序向相应的不见发送控制信号。</p>
<p><code>**运算单元**</code>：接受控制单元的命令，进行算数操作。</p>
<p><code>**存储单元**</code>：包括cpu片内缓存和寄存器组，保存着待处理数据或已经处理过的数据。</p>
<p>经细化概括后，绘制图示：<br><img src="ARM随记/cpu流程.png" alt="cpu"></p>
<p>总结一下，CPU的运行原理就是：<code>控制单元在时序脉冲的作用下，将指令计数器里所指向的指令地址(这个地址是在内存里的)送到地址总线上去，然后CPU将这个地址里的指令读到指令寄存器进行译码。对于执行指令过程中所需要用到的数据，会将数据地址也送到地址总线，然后CPU把数据读到CPU的内部存储单元(就是内部寄存器)暂存起来，最后命令运算单元对数据进行处理加工。周而复始，一直这样执行下去，天荒地老，海枯枝烂，直到停电。</code></p>
<h3 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h3><p>（1）什么是流水线？</p>
<p>　　为提高cpu利用率，加快执行速度，将指令分为若干阶段，可并行执行不同指令的不同阶段，从而多个指令同时执行。</p>
<p>（2）为什么要使用流水线？</p>
<p>　　提高cpu利用率，提升指令执行速度。</p>
<p>（3）5级流水线有哪些？</p>
<p>　　取址，译码/读寄存器、执行/计算有效地址、访问内存（读写）、结果写回寄存器。</p>
<p>（4）流水线阻塞的原因。</p>
<p>　　+ 结构相关：硬件资源不足，冲突。</p>
<p>　　+ 数据相关：一条指令需要前面某条指令的执行结果，而两者并行执行时。</p>
<p>　　+ 控制相关：有跳转语句，分支指令等。</p>
<h3 id="指令集介绍"><a href="#指令集介绍" class="headerlink" title="指令集介绍"></a>指令集介绍</h3><p>ARM公司设计的CPU支持多种指令集。</p>
<p>ARM指令集（32位）</p>
<p>thumb指令集（16位）<br>　<br>thumb指令集（32位）</p>
<p>ARM code对应的cpu状态为ARM State；Thumb code对应的cpu状态为thumb状态。如果程序的某一部分工作在ARM状态，一部分工作在Thumb状态，而这两段代码相互调用，则在编译的时候要加上-apcs/interwork选项。</p>
<h3 id="STM32寄存器介绍。"><a href="#STM32寄存器介绍。" class="headerlink" title="STM32寄存器介绍。"></a>STM32寄存器介绍。</h3><p>通用寄存器：</p>
<p>R0-R7:thumb和thumb-2均可访问<br>R8-R12:少量thumb可访问，thumb-2都可以访问。</p>
<p>专用寄存器：<br>R13（sp） R14（LR） R15(PC) xPSR</p>
<p>R13(SP) stack pointer 堆栈指针，用来保存堆栈的栈顶地址</p>
<p>　　“堆栈”——后进先出，使用的目的是为了支持函数调用，达到现场保护的目的。</p>
<p>用ｃ语言来描述，当程序进入某一函数时，操作形参，不改变实参的值，此时形参就是存储在栈区。假设过程Ａ执行过程中调用Ｂ，此时执行会操作寄存器，但是被操作的寄存器可能有Ａ中的重要数据，改变了重要数据，显然是不对的，这时候就需要现场保护了。将寄存器中的数据存储至内存，当调用结束再从内存中将数据加载（load）到寄存器中。</p>
<p>R14(LR)：linker register 链接寄存器</p>
<p>保存下一条指令，这指令时保存过程调用后返回的值。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/20/ARM随记/" data-id="cjqj4s8v30000rsut4s11xv00" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ARM/">ARM</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-网络编程问题汇总" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/31/网络编程问题汇总/" class="article-date">
  <time datetime="2018-10-31T05:34:25.000Z" itemprop="datePublished">2018-10-31</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习之路/">学习之路</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/31/网络编程问题汇总/">笔试常见问题汇总</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="网络编程的常见问题"><a href="#网络编程的常见问题" class="headerlink" title="网络编程的常见问题"></a>网络编程的常见问题</h2><h3 id="1、TCP和UDP的区别。"><a href="#1、TCP和UDP的区别。" class="headerlink" title="1、TCP和UDP的区别。"></a>1、TCP和UDP的区别。</h3><hr>
<p>这是一个超级常见的问题，只要考网络编程就会有，但是实际上想说全比较难，建议写成两行，对比观看就很清楚。</p>
<p>TCP：面向连接的可靠的字节流服务。用户数据稳定，有序的进行传输，占用资源也多。（关键词，连接，可靠，字节流，稳定有序，占资源）    　　　　</p>
<p>UDP:无连接，不可靠的用户数据报服务。数据尽可能的高效发送，会丢包，数据传输也可能无序。（关键词，无连接，不可靠，数据报，高效无序，资源损耗少）</p>
<h3 id="2、多线程是怎么实现同步的。"><a href="#2、多线程是怎么实现同步的。" class="headerlink" title="2、多线程是怎么实现同步的。"></a>2、多线程是怎么实现同步的。</h3><hr>
<p>这个问题可能是简答题（事件，信号量，互斥锁，），也可能是一个编程题，编程题最常见的就是写两个线程实现交替打印奇数和偶数。就以这个作为例子吧。首先写两个函数，一个打印奇数，一个打印偶数。（用一个全局变量，交替加1就行。）</p>
<h3 id="3、简述一下socket编程。"><a href="#3、简述一下socket编程。" class="headerlink" title="3、简述一下socket编程。"></a>3、简述一下socket编程。</h3><p>　　socket可以理解成ip+端口，或者说是一组接口。以tcp为例，服务端，创立套接字（socket），绑定ip和端口（bind），监听来自客户端的连接（listen），阻塞至有客户端进行连接请求（accept），连接后直接进行数据传输即可（send，recv）最后关闭套接字。而客户端则需要建立一个同ip及端口的套接字，向服务端发送连接请求（connect），成功后数据交互，关闭套接字。</p>
<h3 id="4、简述一下三次握手和四次挥手。"><a href="#4、简述一下三次握手和四次挥手。" class="headerlink" title="4、简述一下三次握手和四次挥手。"></a>4、简述一下三次握手和四次挥手。</h3><p>画图是特别好理解的，但是面试的话呢，就行不通了，这时候就得想办法组织语言了。</p>
<p><strong>tcp的三次握手</strong></p>
<p>第一次握手：客户端向服务端发起连接请求，同步位SYN=1,seq=x；客户端状态SYN-SENT(同步发送)。</p>
<p>第二次握手：此时服务端接收到请求，状态由listen变为SYN-RECV,并回复应答包SYN=1,ACK=1，ack=x+1，seq=y。</p>
<p>第三次握手：客户端接收到服务端的应答包，向服务端发送确认应答包，ACK=1,ack=y+1，seq=z.</p>
<p><img src="./网络编程问题汇总/三次握手.png" alt="图示"></p>
<p><strong>tcp的四次挥手</strong><br>先假设是客户端发起的中断连接请求，这样好描述一些。</p>
<p>第一次挥手：客户端发出连接释放请求FIN=1,seq=x，并停止数据发送，进入FIN-WAIT-1状态。</p>
<p>第二次挥手：服务端收到释放请求后发出确认请求报文段，ACK=1,ack=x+1,seq=y,并进入CLOSE-WAIT状态，此时A-B的连接中断。A接收到B的应答包后，进入FIN-WAIT-2状态。</p>
<p>第三次挥手：客户端没有要发送的数据后，向A发送中断连接请求包，FIN=1,ACK=1,ack=x+1，seq=z。B进入LAST-ACK状态，等待最后的确认。</p>
<p>第四次挥手：服务端收到中断连接包后，发出确认包，ACK=1,seq=y+1，ack=z+1，A进入TIME-WAIT状态，等待2ms后，进入close状态。<br><img src="./网络编程问题汇总/四次挥手.png" alt="图示"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/31/网络编程问题汇总/" data-id="cjqj4s8vy000lrsutrbwguycl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/笔试常见问题汇总/">笔试常见问题汇总</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-字符串操作" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/25/字符串操作/" class="article-date">
  <time datetime="2018-10-24T16:19:43.000Z" itemprop="datePublished">2018-10-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习之路/">学习之路</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/25/字符串操作/">字符串操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h1><p>　　最近面试了很多家，都考到了string操作，如strcpy，strcmp等，虽然感觉很简单，但是写的很乱，其实对于笔试是没有任何好处的，尽量的写的严谨，精致。下面总结一下怎么实现这几个函数。</p>
<h2 id="Strcpy"><a href="#Strcpy" class="headerlink" title="Strcpy"></a>Strcpy</h2><p>　　Strcpy（）这个函数就是用来复制字符串的，拷贝一个字符串，原字符串不能被更改，否则会出错。则被拷贝函数要加上const。所以函数声明为，</p>
<pre><code>char *Strcpy(char *dst,const char *src);
</code></pre><p>为了保证函数的健壮性，要对指针的有效性进行检查，所以要使用assert函数，</p>
<pre><code>assert（dst !=NULL &amp;&amp; src !=NULL）;
</code></pre><p>而后，要保存返回的地址，即dst，而赋值操作要对dst进行移位赋值，所以要定义一个新的指针来进行移位赋值操作。</p>
<pre><code>char *ret = dst；
</code></pre><p>最关键的一步，循环赋值，用while函数</p>
<pre><code>while（(*ret++ = *src++) ！=&apos;\0&apos;)
</code></pre><p>赋值到src 为’\0’,并且’\0’也被赋值，返回值为dst。</p>
<h2 id="内存重叠"><a href="#内存重叠" class="headerlink" title="内存重叠"></a>内存重叠</h2><p>如果考虑到内存重叠，（即两个字符串有共同区域）可以新开辟一段空间去保存被拷贝函数，然后将保存的值存入要拷贝到的地址，还可以通过逆序拷贝的方式。</p>
<p>首先还是函数声明</p>
<pre><code>char *memcpy(char *dst,const char *src，int len)
</code></pre><p>健壮性，指针有效性检测</p>
<pre><code>assert(dst!= NULL &amp;&amp; src != NULL)
</code></pre><p>保存首地址char *ret = dst；</p>
<p>判断是否存在内存重叠，重叠只有一种可能，源字符串的尾部被覆盖，也就是src&lt;= dst&lt;=src+len(len=strlen(src)+1),此时倒叙赋值就好了。这样就避免了重覆盖。没内存重叠的时候就顺序赋值就好了。<br>    if(src&lt;= dst &amp;&amp; dst&lt;=src+len-1)<br>    {<br>        dst=dst+len-1；<br>        src=src+len-1；<br>        while(len–)<br>        {<br>            <em>dst– = </em>src–;<br>        }<br>    }<br>    else<br>    {<br>        while(len–)<br>        <em>dst++ = </em>src++;<br>    }</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/25/字符串操作/" data-id="cjqj4s8vs000frsutrcefoef2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/字符串操作/">字符串操作</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-链表思考" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/19/链表思考/" class="article-date">
  <time datetime="2018-10-19T08:06:40.000Z" itemprop="datePublished">2018-10-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习之路/">学习之路</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/19/链表思考/">链表思考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="链表思考"><a href="#链表思考" class="headerlink" title="链表思考"></a>链表思考</h1><p>链表题能充分的显示出做题者的思维能力，在这就总结一些网络上看到的链表题及个人解法。</p>
<h3 id="一、判断单链表是否有环。"><a href="#一、判断单链表是否有环。" class="headerlink" title="一、判断单链表是否有环。"></a>一、判断单链表是否有环。</h3><p>　　一个单链表若是有环，则无法从头遍历到尾，可以设置不同步的两个指针从头开始遍历，若相遇则代表有环。比如P1=P1-&gt;next，p2=p2-&gt;next-&gt;next。在拜读某位大牛的博客时，看到一篇文章。可以参考。<br><a href="http://ostermiller.org/find_loop_singly_linked_list.html" target="_blank" rel="noopener">http://ostermiller.org/find_loop_singly_linked_list.html</a></p>
<h3 id="二、判断两个单链表是否有交点，有的话，找出交点。"><a href="#二、判断两个单链表是否有交点，有的话，找出交点。" class="headerlink" title="二、判断两个单链表是否有交点，有的话，找出交点。"></a>二、判断两个单链表是否有交点，有的话，找出交点。</h3><p>　　判断是否相交有很多方法，想的最简单的就是两个链表如果相交，链表尾肯定是一样的，那么同时遍历到尾，看是否相等就好了。或者利用上面的办法，将其中一个链表的尾只想另一链表头，判断是否有环。画个图理解一下。<img src="链表思考/1.png" alt="图例"></p>
<p>　　两个链表，表头一样，那么直接找到了交点。如果不一样，假设第一个链表长度为len1，第二个为len2，然后找出长度较长的，让长度较长的链表指针向后移动|len1 - len2| (len1-len2的绝对值)，然后在开始遍历两个链表，判断节点是否相同即可。</p>
<h3 id="三、判断两个单链表是否带环，是的话，找出交点。"><a href="#三、判断两个单链表是否带环，是的话，找出交点。" class="headerlink" title="三、判断两个单链表是否带环，是的话，找出交点。"></a>三、判断两个单链表是否带环，是的话，找出交点。</h3><p>　　这是上述两题的合集，可以先用异步的办法判断是否有环。交点ｐ在环中，然后把环断开，P1=P,P2=P-&gt;next，p-&gt;next=NULL.现在有两个单链表了，一个从head开始，一个从P2开始。利用第二题的办法就能搞定了。</p>
<h3 id="四、删除单链表的某节点"><a href="#四、删除单链表的某节点" class="headerlink" title="四、删除单链表的某节点"></a>四、删除单链表的某节点</h3><p>　　删除节点不是很简单吗，遍历链表，建立一个循环来找到这个节点r，每次没找到都保存一下上一节点pre，删除的时候只需要pre-&gt;next=r-&gt;next,然后r-&gt;next=NULL,free（r），r=NULL。</p>
<p>但是这一点都不cool，还要找到上一节点，还得遍历，还得有头节点。很复杂。那么，我们可不可以鸠占鹊巢呢，我们有这个节点p，有这个节点p的下一个节点p-&gt;next,那么，我们把p-&gt;next的数据全部拷贝到p，然后p-&gt;next=p-&gt;next-&gt;next,再干掉p-&gt;next。成功实现功能。<br><img src="链表思考/2.png" alt="图例"></p>
<h3 id="五，在单链表的某节点前插入节点"><a href="#五，在单链表的某节点前插入节点" class="headerlink" title="五，在单链表的某节点前插入节点"></a>五，在单链表的某节点前插入节点</h3><p>　　常规办法，遍历找到某节点的前节点，然后前节点next指向新节点，新节点next指向某节点。</p>
<p>　　cool点的办法，鸠占鹊巢式，某节点Ｐ后面插入一个新节点，然后把Ｐ的数据复制到新节点中，再给Ｐ赋值（原本新节点的值）。</p>
<h3 id="六、删除单链表的倒数第k个节点。"><a href="#六、删除单链表的倒数第k个节点。" class="headerlink" title="六、删除单链表的倒数第ｋ个节点。"></a>六、删除单链表的倒数第ｋ个节点。</h3><p>　　p1指向头节点，P2指向头节点后的第k个节点，（写个for循环，p2从头开始，每次循环指向下一个），两个p同时向后步进，直到p2到链表尾。 此时p1就是要删除的节点了，再鸠占鹊巢式删除p1,收工。</p>
<h3 id="七、链表排序"><a href="#七、链表排序" class="headerlink" title="七、链表排序"></a>七、链表排序</h3><p>　　简单介绍一个排序，快速排序。其主要思想是找一个标杆，这个标杆左边的数据都比它小，右边的都比它大。此时左右两边又成了新的无序链表，对左右两边的链表再递归调用这个函数。实现功能。</p>
<pre><code>//=============快速排序====================

//交换节点
void swap(node * a, node * b)
{
    int temp = a -&gt; val;
    a -&gt; val = b -&gt; val;
    b -&gt; val = temp;
}

//求中间点
node * partion(node * start, node * end)
{
    if(start == end || start -&gt; next == end)
    {   
        return start;
    }   
    //取第一个元素作为基准元素
    node * p = start, * q = start, * refer = start;
    //从start开始向后进行一次遍历(因为是单链表，无法按从左右向中间遍历的方法)
    while(p != end)
    {   
        if(q -&gt; val &lt; refer -&gt; val) 
        {   
            p =  p -&gt; next;
            swap(p, q); 
        }   
        q = q -&gt; next;
    }   
    swap(p, refer);
    return p;
}
//递归
void quick_sort(node * start, node * end)
{
    if(start == end || start -&gt; next == end)
    {   
        return;
    }   
    node * mid = partion(start, end);
    quick_sort(start, mid);
    quick_sort(mid -&gt; next, end);
}

void quickSort(list mylist)
{
    if((mylist -&gt; next == NULL) || (mylist -&gt; next -&gt; next == NULL))
    {
        return;
    }
    node * start = mylist -&gt; next;
    node * end = NULL;
    quick_sort(start, end);
}
</code></pre><h3 id="八、链表倒置"><a href="#八、链表倒置" class="headerlink" title="八、链表倒置"></a>八、链表倒置</h3><p>很不幸，在写这篇博客前，并没有好好整理关于链表的知识，导致笔试的时候遇见这题，思维异常的混乱，虽然成功的完成了，但是很多细节没有注意，涂改过多，描述也不清晰，导致了笔试的失败（思路差，描述乱，涂改多，以后尽量的把思路写草稿纸上再填写到答题纸上）。好吧，废话不多说，开始介绍第八个问题，链表倒置。</p>
<p>　　一开始，我的思路是，建立一个循环，循环的内容是：每次找到原链表的倒数第一个数和倒数第二个数，把它链接到一个新的链表上，然后把原链表的最后一个数删除。直到原链表空。</p>
<p>　　这样想一点都不cool，而且会给人一种很差劲的感觉，并且，实现起来比较复杂。有一个很好的思想，叫递归。脑子里有一个递归的概念，重复利用。用的时候想成就只有两个数，要做的事就是把这第一个数node，插到最后一个数temp的后面，因为只有两个数，所以，temp=node-&gt;next，所以要做的事就是，temp-&gt;next=node,node-&gt;next=NULL。递归调用这个函数。</p>
<pre><code>    ListNode* reverse(ListNode *node)
{
    if(node==NULL)
    {
        return node;
    }
    if(node-&gt;next==NULL)//跳出
    {
        return node;
    }
    ListNode *preNode=reverse(node-&gt;next);

    ListNode *temp=node-&gt;next;

    temp-&gt;next=node;

    node-&gt;next=NULL;

    return preNode;
}
</code></pre><p>其实不递归也能很cool，写一个循环，循环里prev是node的前驱（第一个node没前驱，所以prev的初值为NULL），每次用temp保存node的后继，然后让node的next指向prev（实现了倒序），此时，这个新的关系成为了新的一个链表，与原链表无关。prev成为下一个node的前驱，也就是现在的node，temp成为新的node。继续循环，直到尾节点结束。</p>
<pre><code>ListNode *Reverse(ListNode *node)
{
    if(node==NULL)
    {
      return node;
    }
    ListNode *prev=NULL;
    while(node-&gt;next!=NULL)
    {
      ListNode *tmp=node-&gt;next;
      node-&gt;next=prev;
      prev=node;
      node=tmp;
    }
}
</code></pre><h3 id="九、有序列表合并"><a href="#九、有序列表合并" class="headerlink" title="九、有序列表合并"></a>九、有序列表合并</h3><p>　　常规思路，肯定是慢慢比较咯，取出链表ａ的值，再取出ｂ的值，比较一下，小的插入到新的链表中。很简单嘛，ｃｏｏｌ一点，这种重复的东西，可以递归嘛。</p>
<p>我们要做的事情是什么呢，找到ａｂ链表中更小的那个数，赋值给一个新的节点result，并返回这个节点。result节点的下一个指向下一个新节点，也就是这个递归函数了，知道ab其中一个为空。</p>
<pre><code>struct node* result = NULL;

    if(a == NULL)
        return (b);
    else if(b == NULL)
        return (a);

    if(a-&gt;data &lt;= b-&gt;data)
    {
        result = a;
        result-&gt;next = SortedMerge(a-&gt;next, b);
    }
    else
    {
        result = b;
        result-&gt;next = SortedMerge(a, b-&gt;next);
    }
    return (result);
</code></pre><h3 id="十、找出链表最中间的数"><a href="#十、找出链表最中间的数" class="headerlink" title="十、找出链表最中间的数"></a>十、找出链表最中间的数</h3><p>龟兔赛跑，兔速度是龟的两倍，当兔跑到终点时，龟就在最中间啦。</p>
<blockquote>
<p>p1=p2=head;<br>p1=p1-&gt;next;p2=p2-&gt;next-&gt;next;</p>
</blockquote>
<p>文终，希望博主下次看自己博客的时候已经拿到offer了吧。加油~</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/19/链表思考/" data-id="cjqj4s8ww0013rsutbkysjmuk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数据结构/">数据结构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-linux安装arm-linux-gcc交叉编译环境" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/15/linux安装arm-linux-gcc交叉编译环境/" class="article-date">
  <time datetime="2018-10-15T13:10:14.000Z" itemprop="datePublished">2018-10-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/学习之路/">学习之路</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/15/linux安装arm-linux-gcc交叉编译环境/">linux安装arm-linux-gcc交叉编译环境</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="linux安装交叉arm-linux-gcc编译环境搭建过程"><a href="#linux安装交叉arm-linux-gcc编译环境搭建过程" class="headerlink" title="linux安装交叉arm-linux-gcc编译环境搭建过程"></a>linux安装交叉arm-linux-gcc编译环境搭建过程</h1><p>linux版本：Ubuntu 12.04，编译器：arm-2014.05</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先简单介绍一下，所谓的搭建交叉编译环境，即安装、配置交叉编译工具链。在该环境下编译出嵌入式Linux系统所需的操作系统、应用程序等，然后再上传到目标机上。</p>
<p>交叉编译工具链是为了编译、链接、处理和调试跨平台体系结构的程序代码。对于交叉开发的工具链来说，在文件名称上加了一个前缀，用来区别本地的工具链。例如，arm-linux-表示是对arm的交叉编译工具链；arm-linux-gcc表示是使用gcc的编译器。除了体系结构相关的编译选项以外，其使用方法与Linux主机上的gcc相同，所以Linux编程技术对于嵌入式同样适用。不过，并不是任何一个版本拿来都能用，各种软件包往往存在版本匹配问题。</p>
<p>那么gcc和arm-linux-gcc的区别是什么呢？区别就是gcc是linux下的C语言编译器，编译出来的程序在本地执行，而arm-linux-gcc用来在linux下跨平台的C语言编译器，编译出来的程序在目标机(如ARM平台)上执行，嵌入式开发应使用嵌入式交叉编译工具链。</p>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><p>首先将下载好的压缩包存放在ubantu某目录下，解压：</p>
<blockquote>
<p>sudo tar -xjvf arm-linux-gcc-2014.tar.bz2 </p>
</blockquote>
<p>移动到目标目录：usr/local/arm</p>
<blockquote>
<p>sudo cp arm-2014.05 /usr/local/arm</p>
</blockquote>
<p>如果没有arm文件夹的话就自己新建一个.</p>
<blockquote>
<p>cd /usr/local/arm</p>
<p>mkdir arm</p>
</blockquote>
<p>更改环境变量：</p>
<blockquote>
<p>sudo vim /etc/profile</p>
</blockquote>
<p>在最后添加</p>
<blockquote>
<p>export PATH=$PATH:usr/local/arm/arm-2014.05/bin</p>
</blockquote>
<p>在上一命令中，$PATH:后面添加的是安装包解压后的路径，为确保路径的准确性，移动到复制到的目标路径，执行pwd指令，获取准确路径，添加环境变量。</p>
<p>进入所添加的环境变量的路径：</p>
<blockquote>
<p>cd /etc/local/arm/arm-2014.05/bin</p>
</blockquote>
<p>建立软链接：</p>
<blockquote>
<p>sudo ln -s arm-none-linux-gnueabi-gcc arm-linux-gcc</p>
</blockquote>
<p>重启：</p>
<blockquote>
<p>sudo reboot</p>
</blockquote>
<p>重启后打开终端，检查环境变量是否更改</p>
<blockquote>
<p>echo $PATH</p>
</blockquote>
<p>如果显示有之前添加的路径，则成功加入环境变量，但不一定成功，还需输入：</p>
<blockquote>
<p>which arm-linux-gcc</p>
</blockquote>
<p>如果显示的路径与自身路径不符，大致是之前所安装的旧版本，这时，可以进入所显示的路径，删除之前所安装的旧版本。</p>
<p>而后再次检查：<br>arm-linux-gcc -v</p>
<p>显示版本为2014.05则安装完成。</p>
<h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h2><ul>
<li><p>在此之前，安装包解压的路径可以是任意的，但建议是本文所安装的路径。</p>
</li>
<li><p>环境变量的修改有多种方式，本文介绍的是仅当前用户可用的方式，比较安全。想了解其他的安装方式可参考其余大神的作品。</p>
</li>
<li><p>让环境变量的路径生效可手动，可重启，由于ubantu中的.bashrc文件的位置千奇百怪，所以在不知道得情况下重启是一个好的选择。</p>
</li>
<li><p>手动生效方式:</p>
</li>
</ul>
<blockquote>
<p>source /root/.bashrc<br>souce/home/xxx/.bashrc</p>
</blockquote>
<p>文终。</p>
<p>- </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/15/linux安装arm-linux-gcc交叉编译环境/" data-id="cjqj4s8vk0006rsutyiyfwpwn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习之路/">学习之路</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随记/">随记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ARM/">ARM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/字符串操作/">字符串操作</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/电脑随记/">电脑随记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔试常见问题汇总/">笔试常见问题汇总</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/进程与线程/">进程与线程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ARM/" style="font-size: 10px;">ARM</a> <a href="/tags/c/" style="font-size: 10px;">c++</a> <a href="/tags/hexo/" style="font-size: 20px;">hexo</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/字符串操作/" style="font-size: 10px;">字符串操作</a> <a href="/tags/数据结构/" style="font-size: 10px;">数据结构</a> <a href="/tags/电脑随记/" style="font-size: 10px;">电脑随记</a> <a href="/tags/笔试常见问题汇总/" style="font-size: 10px;">笔试常见问题汇总</a> <a href="/tags/进程与线程/" style="font-size: 20px;">进程与线程</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/04/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2019/01/04/git-hexo搭建前传/">git-hexo搭建前传</a>
          </li>
        
          <li>
            <a href="/2018/12/15/自电脑重装所需步骤/">自电脑重装所需步骤</a>
          </li>
        
          <li>
            <a href="/2018/12/04/UART-IIC-SPI了解及思考/">UART,IIC,SPI了解及思考</a>
          </li>
        
          <li>
            <a href="/2018/12/04/简易的hexo搭建二/">简易hexo的搭建　　（二）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>